import 'package:get/get.dart';
import '../models/chat_model.dart';
import '../models/message_model.dart';
import '../models/user_model.dart';
import '../services/mock_data_service.dart';
import '../controllers/auth_controller.dart';

// Message controller for managing chat and message data
class MessageController extends GetxController {
  final MockDataService _dataService = MockDataService();

  // Observable chat list
  final RxList<ChatModel> _chats = <ChatModel>[].obs;
  List<ChatModel> get chats => _chats;

  // Observable messages for current chat
  final RxList<MessageModel> _messages = <MessageModel>[].obs;
  List<MessageModel> get messages => _messages;

  // Selected chat
  final Rx<ChatModel?> _selectedChat = Rx<ChatModel?>(null);
  ChatModel? get selectedChat => _selectedChat.value;

  // Selected user for new chat
  final Rx<UserModel?> _selectedUser = Rx<UserModel?>(null);
  UserModel? get selectedUser => _selectedUser.value;

  // Loading state
  final RxBool _isLoading = false.obs;
  bool get isLoading => _isLoading.value;

  // Error message
  final RxString _errorMessage = ''.obs;
  String get errorMessage => _errorMessage.value;

  // Get all chats for current user
  Future<void> getUserChats(String userId) async {
    _isLoading.value = true;
    _errorMessage.value = '';

    try {
      final userChats = await _dataService.getUserChats(userId);
      _chats.assignAll(userChats);
    } catch (e) {
      _errorMessage.value = 'Failed to get chats: ${e.toString()}';
    } finally {
      _isLoading.value = false;
    }
  }

  // Get messages for a specific chat
  Future<void> getChatMessages(String chatId) async {
    // Use a safer approach to update loading state
    try {
      _isLoading.value = true;
      _errorMessage.value = '';

      final chatMessages = await _dataService.getChatMessages(chatId);

      // Use Future.microtask to avoid setState during build
      await Future.microtask(() {
        _messages.assignAll(chatMessages);
      });

      // Mark messages as read
      await markMessagesAsRead(chatId);
    } catch (e) {
      _errorMessage.value = 'Failed to get messages: ${e.toString()}';
    } finally {
      _isLoading.value = false;
    }
  }

  // Send a new message
  Future<bool> sendMessage({
    required String chatId,
    required String senderId,
    required String receiverId,
    required String content,
    String? attachmentUrl,
    String? attachmentType,
  }) async {
    _isLoading.value = true;
    _errorMessage.value = '';

    try {
      final message = MessageModel(
        id: '', // Will be generated by the service
        chatId: chatId,
        senderId: senderId,
        receiverId: receiverId,
        content: content,
        timestamp: DateTime.now(),
        isRead: false,
        attachmentUrl: attachmentUrl,
        attachmentType: attachmentType,
      );

      final newMessage = await _dataService.sendMessage(message);
      _messages.add(newMessage);

      // Update the chat with the new message
      await _updateChatWithNewMessage(chatId, newMessage);

      return true;
    } catch (e) {
      _errorMessage.value = 'Failed to send message: ${e.toString()}';
      return false;
    } finally {
      _isLoading.value = false;
    }
  }

  // Create a new chat
  Future<String?> createChat({
    required String currentUserId,
    required String otherUserId,
  }) async {
    _isLoading.value = true;
    _errorMessage.value = '';

    try {
      // Check if chat already exists
      final existingChat = _chats.firstWhereOrNull(
        (chat) =>
            chat.participantIds.contains(currentUserId) &&
            chat.participantIds.contains(otherUserId),
      );

      if (existingChat != null) {
        _selectedChat.value = existingChat;
        return existingChat.id;
      }

      // Create new chat
      final newChat = await _dataService.createChat(currentUserId, otherUserId);

      _chats.add(newChat);
      _selectedChat.value = newChat;
      return newChat.id;
    } catch (e) {
      _errorMessage.value = 'Failed to create chat: ${e.toString()}';
      return null;
    } finally {
      _isLoading.value = false;
    }
  }

  // Mark messages as read
  Future<void> markMessagesAsRead(String chatId) async {
    try {
      await _dataService.markMessagesAsRead(chatId);

      // Use Future.microtask to avoid setState during build
      await Future.microtask(() {
        // Update local messages
        for (int i = 0; i < _messages.length; i++) {
          if (!_messages[i].isRead) {
            _messages[i] = _messages[i].copyWith(isRead: true);
          }
        }

        // Update chat unread status
        final chatIndex = _chats.indexWhere((chat) => chat.id == chatId);
        if (chatIndex != -1) {
          _chats[chatIndex] = _chats[chatIndex].copyWith(
            hasUnreadMessages: false,
            unreadCount: 0,
          );
        }
      });
    } catch (e) {
      _errorMessage.value = 'Failed to mark messages as read: ${e.toString()}';
    }
  }

  // Set selected chat
  void setSelectedChat(ChatModel chat) {
    // Use Future.microtask to avoid setState during build
    Future.microtask(() {
      _selectedChat.value = chat;
    });
  }

  // Set selected user for new chat
  void setSelectedUser(UserModel user) {
    // Use Future.microtask to avoid setState during build
    Future.microtask(() {
      _selectedUser.value = user;
    });
  }

  // Update chat with new message
  Future<void> _updateChatWithNewMessage(
    String chatId,
    MessageModel message,
  ) async {
    final chatIndex = _chats.indexWhere((chat) => chat.id == chatId);
    if (chatIndex != -1) {
      _chats[chatIndex] = _chats[chatIndex].copyWith(
        lastMessageAt: message.timestamp,
        lastMessageContent: message.content,
        lastMessageSenderId: message.senderId,
      );
    }
  }

  // Search chats by user name
  List<ChatModel> searchChatsByName(String query, List<UserModel> allUsers) {
    if (query.isEmpty) return chats;

    return chats.where((chat) {
      // Find the other participant in the chat
      final otherParticipantId = chat.participantIds.firstWhere(
        (id) => id != Get.find<AuthController>().user?.id,
        orElse: () => '',
      );

      if (otherParticipantId.isEmpty) return false;

      // Find the user by ID
      final otherUser = allUsers.firstWhereOrNull(
        (user) => user.id == otherParticipantId,
      );

      if (otherUser == null) return false;

      // Check if the user name contains the query
      return otherUser.name.toLowerCase().contains(query.toLowerCase());
    }).toList();
  }
}
