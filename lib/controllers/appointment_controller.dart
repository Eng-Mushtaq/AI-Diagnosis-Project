import 'package:get/get.dart';
import 'dart:async';
import '../models/appointment_model.dart';
import '../models/doctor_model.dart';
import '../services/mock_data_service.dart';
import '../services/supabase_service.dart';

// Appointment controller for managing appointments
class AppointmentController extends GetxController {
  final SupabaseService _supabaseService = Get.find<SupabaseService>();
  final MockDataService _mockDataService =
      MockDataService(); // Keep for fallback and doctor data

  // Observable appointments list
  final RxList<AppointmentModel> _appointments = <AppointmentModel>[].obs;
  List<AppointmentModel> get appointments => _appointments;

  // Selected appointment
  final Rx<AppointmentModel?> _selectedAppointment = Rx<AppointmentModel?>(
    null,
  );
  AppointmentModel? get selectedAppointment => _selectedAppointment.value;

  // Timer for real-time updates
  Timer? _appointmentPollingTimer;

  // Selected date for booking
  final Rx<DateTime> _selectedDate = DateTime.now().obs;
  DateTime get selectedDate => _selectedDate.value;

  // Selected time slot for booking
  final RxString _selectedTimeSlot = ''.obs;
  String get selectedTimeSlot => _selectedTimeSlot.value;

  // Selected appointment type
  final RxString _selectedAppointmentType = 'video'.obs;
  String get selectedAppointmentType => _selectedAppointmentType.value;

  // Loading state
  final RxBool _isLoading = false.obs;
  bool get isLoading => _isLoading.value;

  // Error message
  final RxString _errorMessage = ''.obs;
  String get errorMessage => _errorMessage.value;

  // Get user appointments
  Future<void> getUserAppointments(String userId) async {
    _isLoading.value = true;
    _errorMessage.value = '';

    try {
      // Use Supabase service to get appointments
      final userAppointments = await _supabaseService.getUserAppointments(
        userId,
      );
      _appointments.assignAll(userAppointments);
    } catch (e) {
      _errorMessage.value = 'Failed to get appointments: ${e.toString()}';

      // Fallback to mock data if Supabase fails
      try {
        final mockAppointments = await _mockDataService.getUserAppointments(
          userId,
        );
        _appointments.assignAll(mockAppointments);
        _errorMessage.value =
            'Using mock data (Supabase error: ${e.toString()})';
      } catch (mockError) {
        _errorMessage.value =
            'Failed to get appointments: ${e.toString()}. Mock data error: ${mockError.toString()}';
      }
    } finally {
      _isLoading.value = false;
    }
  }

  // Book appointment
  Future<bool> bookAppointment({
    required String userId,
    required String doctorId,
    required DateTime appointmentDate,
    required String timeSlot,
    required String type,
    required String reason,
    required double fee,
    List<String>? attachments,
    String? notes,
  }) async {
    _isLoading.value = true;
    _errorMessage.value = '';

    try {
      final appointment = AppointmentModel(
        id: '', // Will be generated by the service
        userId: userId,
        doctorId: doctorId,
        appointmentDate: appointmentDate,
        timeSlot: timeSlot,
        type: type,
        status: 'scheduled',
        reason: reason,
        attachments: attachments,
        notes: notes,
        fee: fee,
        prescriptionUrl: null,
        createdAt: DateTime.now(),
      );

      // Use Supabase service to book appointment
      final newAppointment = await _supabaseService.bookAppointment(
        appointment,
      );
      _appointments.add(newAppointment);
      return true;
    } catch (e) {
      _errorMessage.value = 'Failed to book appointment: ${e.toString()}';

      // Fallback to mock data if Supabase fails
      try {
        final mockAppointment = await _mockDataService.bookAppointment(
          AppointmentModel(
            id: '', // Will be generated by the service
            userId: userId,
            doctorId: doctorId,
            appointmentDate: appointmentDate,
            timeSlot: timeSlot,
            type: type,
            status: 'scheduled',
            reason: reason,
            attachments: attachments,
            notes: notes,
            fee: fee,
            prescriptionUrl: null,
            createdAt: DateTime.now(),
          ),
        );
        _appointments.add(mockAppointment);
        _errorMessage.value =
            'Using mock data (Supabase error: ${e.toString()})';
        return true;
      } catch (mockError) {
        _errorMessage.value =
            'Failed to book appointment: ${e.toString()}. Mock data error: ${mockError.toString()}';
        return false;
      }
    } finally {
      _isLoading.value = false;
    }
  }

  // Update appointment status
  Future<bool> updateAppointmentStatus(
    String appointmentId,
    String status,
  ) async {
    _isLoading.value = true;
    _errorMessage.value = '';

    try {
      // Use Supabase service to update appointment status
      final updatedAppointment = await _supabaseService.updateAppointmentStatus(
        appointmentId,
        status,
      );

      // Update the appointment in the local list
      final index = _appointments.indexWhere(
        (appointment) => appointment.id == appointmentId,
      );
      if (index != -1) {
        _appointments[index] = updatedAppointment;
      }

      return true;
    } catch (e) {
      _errorMessage.value =
          'Failed to update appointment status: ${e.toString()}';
      return false;
    } finally {
      _isLoading.value = false;
    }
  }

  // Set selected appointment
  void setSelectedAppointment(AppointmentModel appointment) {
    _selectedAppointment.value = appointment;
  }

  // Clear selected appointment
  void clearSelectedAppointment() {
    _selectedAppointment.value = null;
  }

  // Set selected date
  void setSelectedDate(DateTime date) {
    _selectedDate.value = date;
    _selectedTimeSlot.value = ''; // Reset time slot when date changes
  }

  // Set selected time slot
  void setSelectedTimeSlot(String timeSlot) {
    _selectedTimeSlot.value = timeSlot;
  }

  // Set selected appointment type
  void setSelectedAppointmentType(String type) {
    _selectedAppointmentType.value = type;
  }

  // Get upcoming appointments
  List<AppointmentModel> getUpcomingAppointments() {
    final now = DateTime.now();
    return _appointments
        .where(
          (appointment) =>
              appointment.status == 'scheduled' &&
              appointment.appointmentDate.isAfter(now),
        )
        .toList();
  }

  // Observable list for doctor's upcoming appointments
  final RxList<AppointmentModel> _upcomingAppointments =
      <AppointmentModel>[].obs;
  List<AppointmentModel> get upcomingAppointments => _upcomingAppointments;

  // Get doctor's upcoming appointments
  Future<void> getDoctorUpcomingAppointments(String doctorId) async {
    _isLoading.value = true;
    _errorMessage.value = '';

    try {
      // Use Supabase service to get doctor's appointments
      final doctorAppointments = await _supabaseService.getDoctorAppointments(
        doctorId,
      );

      // Filter for upcoming appointments
      final now = DateTime.now();
      final upcoming =
          doctorAppointments
              .where(
                (appointment) =>
                    appointment.status == 'scheduled' &&
                    appointment.appointmentDate.isAfter(now),
              )
              .toList();

      _upcomingAppointments.assignAll(upcoming);
    } catch (e) {
      _errorMessage.value =
          'Failed to get doctor appointments: ${e.toString()}';

      // Fallback to mock data if Supabase fails
      try {
        final mockAppointments = await _mockDataService.getDoctorAppointments(
          doctorId,
        );

        // Filter for upcoming appointments
        final now = DateTime.now();
        final upcoming =
            mockAppointments
                .where(
                  (appointment) =>
                      appointment.status == 'scheduled' &&
                      appointment.appointmentDate.isAfter(now),
                )
                .toList();

        _upcomingAppointments.assignAll(upcoming);
        _errorMessage.value =
            'Using mock data (Supabase error: ${e.toString()})';
      } catch (mockError) {
        _errorMessage.value =
            'Failed to get doctor appointments: ${e.toString()}. Mock data error: ${mockError.toString()}';
      }
    } finally {
      _isLoading.value = false;
    }
  }

  // Get past appointments
  List<AppointmentModel> getPastAppointments() {
    final now = DateTime.now();
    return _appointments
        .where(
          (appointment) =>
              appointment.status == 'completed' ||
              (appointment.status == 'scheduled' &&
                  appointment.appointmentDate.isBefore(now)),
        )
        .toList();
  }

  // Get available time slots for selected date and doctor
  List<String> getAvailableTimeSlots(DoctorModel doctor) {
    final dayOfWeek = _getDayOfWeek(_selectedDate.value);

    // Check if doctor is available on selected day
    if (doctor.availableDays == null ||
        !doctor.availableDays!.contains(dayOfWeek)) {
      return [];
    }

    // Get time slots for selected day
    if (doctor.availableTimeSlots == null ||
        !doctor.availableTimeSlots!.containsKey(dayOfWeek)) {
      return [];
    }

    // Get all available time slots for the day
    final allTimeSlots = doctor.availableTimeSlots![dayOfWeek]!;

    // Filter out already booked time slots
    final bookedTimeSlots = _getBookedTimeSlots(doctor.id, _selectedDate.value);

    return allTimeSlots
        .where((slot) => !bookedTimeSlots.contains(slot))
        .toList();
  }

  // Get already booked time slots for a specific doctor and date
  List<String> _getBookedTimeSlots(String doctorId, DateTime date) {
    // Check if the date is the same (year, month, day)
    bool isSameDate(DateTime a, DateTime b) {
      return a.year == b.year && a.month == b.month && a.day == b.day;
    }

    // Filter appointments for the specified doctor and date
    return _appointments
        .where(
          (appointment) =>
              appointment.doctorId == doctorId &&
              isSameDate(appointment.appointmentDate, date) &&
              appointment.status == 'scheduled',
        )
        .map((appointment) => appointment.timeSlot)
        .toList();
  }

  // Get day of week as string
  String _getDayOfWeek(DateTime date) {
    switch (date.weekday) {
      case 1:
        return 'Monday';
      case 2:
        return 'Tuesday';
      case 3:
        return 'Wednesday';
      case 4:
        return 'Thursday';
      case 5:
        return 'Friday';
      case 6:
        return 'Saturday';
      case 7:
        return 'Sunday';
      default:
        return '';
    }
  }

  // Check if selected date is available for doctor
  bool isDateAvailable(DoctorModel doctor, DateTime date) {
    final dayOfWeek = _getDayOfWeek(date);
    return doctor.availableDays != null &&
        doctor.availableDays!.contains(dayOfWeek);
  }

  // Get next available date for doctor
  DateTime? getNextAvailableDate(DoctorModel doctor) {
    if (doctor.availableDays == null || doctor.availableDays!.isEmpty) {
      return null;
    }

    final now = DateTime.now();
    DateTime checkDate = now;

    // Check next 30 days
    for (int i = 0; i < 30; i++) {
      checkDate = now.add(Duration(days: i));
      if (isDateAvailable(doctor, checkDate)) {
        return checkDate;
      }
    }

    return null;
  }

  // Upload prescription for an appointment
  Future<bool> uploadPrescription(String appointmentId, String filePath) async {
    _isLoading.value = true;
    _errorMessage.value = '';

    try {
      // Use Supabase service to upload prescription
      final prescriptionUrl = await _supabaseService.uploadPrescription(
        filePath,
        appointmentId,
      );

      // Update the appointment in the local list
      final index = _appointments.indexWhere(
        (appointment) => appointment.id == appointmentId,
      );
      if (index != -1) {
        _appointments[index] = _appointments[index].copyWith(
          prescriptionUrl: prescriptionUrl,
        );
      }

      return true;
    } catch (e) {
      _errorMessage.value = 'Failed to upload prescription: ${e.toString()}';
      return false;
    } finally {
      _isLoading.value = false;
    }
  }

  // Get prescription URL for an appointment
  Future<String?> getPrescriptionUrl(String appointmentId) async {
    try {
      // First check if the appointment is in the local list
      final appointment = _appointments.firstWhereOrNull(
        (a) => a.id == appointmentId,
      );
      if (appointment != null && appointment.prescriptionUrl != null) {
        return appointment.prescriptionUrl;
      }

      // If not found in local list or no prescription URL, fetch from Supabase
      return await _supabaseService.getPrescriptionUrl(appointmentId);
    } catch (e) {
      _errorMessage.value = 'Failed to get prescription URL: ${e.toString()}';
      return null;
    }
  }

  // Start real-time updates for appointments
  void startAppointmentPolling(String userId) {
    // Stop any existing polling
    stopAppointmentPolling();

    // Start polling for appointment updates
    _appointmentPollingTimer = _supabaseService.setupAppointmentPolling(
      userId,
      (updatedAppointments) {
        // Update the appointments list
        _appointments.assignAll(updatedAppointments);
      },
    );
  }

  // Stop real-time updates for appointments
  void stopAppointmentPolling() {
    _appointmentPollingTimer?.cancel();
    _appointmentPollingTimer = null;
  }

  // Dispose resources
  @override
  void onClose() {
    stopAppointmentPolling();
    super.onClose();
  }
}
