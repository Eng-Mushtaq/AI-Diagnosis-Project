import 'package:get/get.dart';
import '../models/appointment_model.dart';
import '../models/doctor_model.dart';
import '../services/mock_data_service.dart';

// Appointment controller for managing appointments
class AppointmentController extends GetxController {
  final MockDataService _dataService = MockDataService();
  
  // Observable appointments list
  final RxList<AppointmentModel> _appointments = <AppointmentModel>[].obs;
  List<AppointmentModel> get appointments => _appointments;
  
  // Selected appointment
  final Rx<AppointmentModel?> _selectedAppointment = Rx<AppointmentModel?>(null);
  AppointmentModel? get selectedAppointment => _selectedAppointment.value;
  
  // Selected date for booking
  final Rx<DateTime> _selectedDate = DateTime.now().obs;
  DateTime get selectedDate => _selectedDate.value;
  
  // Selected time slot for booking
  final RxString _selectedTimeSlot = ''.obs;
  String get selectedTimeSlot => _selectedTimeSlot.value;
  
  // Selected appointment type
  final RxString _selectedAppointmentType = 'video'.obs;
  String get selectedAppointmentType => _selectedAppointmentType.value;
  
  // Loading state
  final RxBool _isLoading = false.obs;
  bool get isLoading => _isLoading.value;
  
  // Error message
  final RxString _errorMessage = ''.obs;
  String get errorMessage => _errorMessage.value;
  
  // Get user appointments
  Future<void> getUserAppointments(String userId) async {
    _isLoading.value = true;
    _errorMessage.value = '';
    
    try {
      final userAppointments = await _dataService.getUserAppointments(userId);
      _appointments.assignAll(userAppointments);
    } catch (e) {
      _errorMessage.value = 'Failed to get appointments: ${e.toString()}';
    } finally {
      _isLoading.value = false;
    }
  }
  
  // Book appointment
  Future<bool> bookAppointment({
    required String userId,
    required String doctorId,
    required DateTime appointmentDate,
    required String timeSlot,
    required String type,
    required String reason,
    required double fee,
    List<String>? attachments,
    String? notes,
  }) async {
    _isLoading.value = true;
    _errorMessage.value = '';
    
    try {
      final appointment = AppointmentModel(
        id: '', // Will be generated by the service
        userId: userId,
        doctorId: doctorId,
        appointmentDate: appointmentDate,
        timeSlot: timeSlot,
        type: type,
        status: 'scheduled',
        reason: reason,
        attachments: attachments,
        notes: notes,
        fee: fee,
        prescriptionUrl: null,
        createdAt: DateTime.now(),
      );
      
      final newAppointment = await _dataService.bookAppointment(appointment);
      _appointments.add(newAppointment);
      return true;
    } catch (e) {
      _errorMessage.value = 'Failed to book appointment: ${e.toString()}';
      return false;
    } finally {
      _isLoading.value = false;
    }
  }
  
  // Set selected appointment
  void setSelectedAppointment(AppointmentModel appointment) {
    _selectedAppointment.value = appointment;
  }
  
  // Clear selected appointment
  void clearSelectedAppointment() {
    _selectedAppointment.value = null;
  }
  
  // Set selected date
  void setSelectedDate(DateTime date) {
    _selectedDate.value = date;
    _selectedTimeSlot.value = ''; // Reset time slot when date changes
  }
  
  // Set selected time slot
  void setSelectedTimeSlot(String timeSlot) {
    _selectedTimeSlot.value = timeSlot;
  }
  
  // Set selected appointment type
  void setSelectedAppointmentType(String type) {
    _selectedAppointmentType.value = type;
  }
  
  // Get upcoming appointments
  List<AppointmentModel> getUpcomingAppointments() {
    final now = DateTime.now();
    return _appointments
        .where((appointment) =>
            appointment.status == 'scheduled' &&
            appointment.appointmentDate.isAfter(now))
        .toList();
  }
  
  // Get past appointments
  List<AppointmentModel> getPastAppointments() {
    final now = DateTime.now();
    return _appointments
        .where((appointment) =>
            appointment.status == 'completed' ||
            (appointment.status == 'scheduled' &&
                appointment.appointmentDate.isBefore(now)))
        .toList();
  }
  
  // Get available time slots for selected date and doctor
  List<String> getAvailableTimeSlots(DoctorModel doctor) {
    final dayOfWeek = _getDayOfWeek(_selectedDate.value);
    
    // Check if doctor is available on selected day
    if (doctor.availableDays == null ||
        !doctor.availableDays!.contains(dayOfWeek)) {
      return [];
    }
    
    // Get time slots for selected day
    if (doctor.availableTimeSlots == null ||
        !doctor.availableTimeSlots!.containsKey(dayOfWeek)) {
      return [];
    }
    
    return doctor.availableTimeSlots![dayOfWeek]!;
  }
  
  // Get day of week as string
  String _getDayOfWeek(DateTime date) {
    switch (date.weekday) {
      case 1:
        return 'Monday';
      case 2:
        return 'Tuesday';
      case 3:
        return 'Wednesday';
      case 4:
        return 'Thursday';
      case 5:
        return 'Friday';
      case 6:
        return 'Saturday';
      case 7:
        return 'Sunday';
      default:
        return '';
    }
  }
  
  // Check if selected date is available for doctor
  bool isDateAvailable(DoctorModel doctor, DateTime date) {
    final dayOfWeek = _getDayOfWeek(date);
    return doctor.availableDays != null &&
        doctor.availableDays!.contains(dayOfWeek);
  }
  
  // Get next available date for doctor
  DateTime? getNextAvailableDate(DoctorModel doctor) {
    if (doctor.availableDays == null || doctor.availableDays!.isEmpty) {
      return null;
    }
    
    final now = DateTime.now();
    DateTime checkDate = now;
    
    // Check next 30 days
    for (int i = 0; i < 30; i++) {
      checkDate = now.add(Duration(days: i));
      if (isDateAvailable(doctor, checkDate)) {
        return checkDate;
      }
    }
    
    return null;
  }
}
